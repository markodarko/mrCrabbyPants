<HTML>
	
<CANVAS id='gamewindow'></CANVAS>
<STYLE>
canvas{
	display:block;
	background:#f8d878;
	user-select:none;
}
*{
	margin:0
}
</STYLE>
<SCRIPT src = pixelfont3.js></SCRIPT>
<SCRIPT>

var canvas = document.getElementById('gamewindow')
var ctx = canvas.getContext('2d')

const GRID = 32;
const GRID_THIRD = Math.floor(GRID/3);
const SCALE = 1;

const C_WIDTH = canvas.width = (GRID * 17);
const C_HEIGHT = canvas.height = (GRID * 20);
canvas.width *=SCALE;
canvas.height*=SCALE;
ctx.scale(SCALE,SCALE);

function randINT(n){
	return Math.floor(Math.random()*(n+1))
}

const COLORS = {
	red:	'#881400',//'#007800',//'#e40058',
	red2:	'#f83800',
	yellow:	'#f8d878',
	yellow2:'#f8b800',
	orange:	'#fca044',//'#f87858',
	orange2:'#f8b800',
	orange3:'#f87858',
	shadow:	'#a81000',
	blue:	'#3cbcfc',
	Dblue:	'#004058'
}
var controller = {
	up: 0,
	pressed:0,
	down: 0
}

class Sprite{
	constructor(sprite_data,speed = 10){
		this.maxFrames = sprite_data.length;
		this.currentFrame = 0;
		this.img = sprite_data
		this.maxTime = speed;
		this.time = 0;
	}
	draw(x=0,y=0){
		this.img[this.currentFrame].forEach(block =>{
			ctx.fillRect(block[0]+x,block[1]+y,block[2],block[3])
		})
		this.time++
		if (this.time > this.maxTime){
			this.time=0
			this.currentFrame = (this.currentFrame+1)%this.maxFrames;
		}
	}
}

const SPRITE_DATA = {
	crab_dat:
	[
	//frame 1
		[
			[0,0,32,16],//body
			[4,-4,4,4],[24,-4,4,4],//eyes
			[0,16,4,8],[8,16,4,8],[20,16,4,8],[28,16,4,8],//legs
			[-12,4,56,4],//arms
			[-12,-4,4,8],[-16,-12,4,8],[-8,-12,4,8],//left claw
			[40,-4,4,8],[36,-12,4,8],[44,-12,4,8]//right claw
		],
	//frame 2
		[
			[0,-4,32,20],//body
			[4,-8,4,4],[24,-8,4,4],//eyes
			[-4,16,4,8],[4,16,4,8],[24,16,4,8],[32,16,4,8],//legs
			[-12,4,56,4],//arms
			[-16,0,4,8],[-20,-8,4,8],[-12,-8,4,8],//left claw
			[44,0,4,8],[40,-8,4,8],[48,-8,4,8]//right claw
		]
	],
	mine_dat:
	[
	//frame1
		[
		[4,4,24,24],//body
		[-6,14,44,4],[14,-4,4,40],//arms
		[0,0,4,4],[28,0,4,4],[0,28,4,4],[28,28,4,4]//corners
		],
	//frame 2
		[
		[4,4,24,24],//body
		[-4,14,40,4],[14,-6,4,44],//arms
		[0,0,4,4],[28,0,4,4],[0,28,4,4],[28,28,4,4]//corners
		]
	]
}

const SPRITES = {
	crab:new Sprite(SPRITE_DATA.crab_dat),
	mine:new Sprite(SPRITE_DATA.mine_dat,30)
}

function collideCheck(obj1,obj2,dx=0,dy=0){
	const 	x1 = obj1.x + obj1.offsetX,
			y1 = obj1.y + obj1.offsetY,
			w1 = obj1.w - obj1.offsetX * 2,
			h1 = obj1.h - obj1.offsetY * 2;
			
	for(let i=0; i < obj2.length; i++){
		if (obj2[i].dead) continue;
		const	w2 = obj2[i].w - obj2[i].offsetX * 2,
				h2 = obj2[i].h - obj2[i].offsetY * 2,
				y2 = obj2[i].y + obj2[i].offsetY,
				x2 = obj2[i].x + obj2[i].offsetX;
		if ((x1 + dx >= x2 + w2) || (x1 + w1 + dx <= x2)) continue;
		if ((y1 + dy >= y2 + h2) || (y1 + h1 + dy <= y2)) continue;
		return obj2[i];
	}
	return 0
}

class Block{
	constructor(x,y,offsetX = 0,offsetY = 0){
		this.x = x * GRID;
		this.y = y * GRID;
		this.w = this.h = GRID;
		this.offsetX = offsetX;
		this.offsetY = offsetY;
		this.dead = 0;
	}
	drawAlpha(color = 'white'){
		ctx.fillStyle = color;
		ctx.save()
		ctx.globalAlpha = this.alpha;
		ctx.fillRect(this.x,this.y,this.w,this.h)
		ctx.restore()
	}
	
}

class Water extends Block{
	constructor(x,y){
		super(x,y);
		this.color=COLORS.blue;
		this.alpha = randINT(50)/100;
		this.sign = -1;
	}
	draw(){
		ctx.fillStyle = this.color;
		ctx.fillRect(this.x,this.y,this.w,this.h);
		this.drawAlpha()
		this.alpha += this.sign * .005
		if (this.alpha < 0){
			this.alpha = 0;
			this.sign = 1;
		}else if (this.alpha > .5){
			this.alpha = .5;
			this.sign = -1;
		}
	}
}
class Wall extends Block{
	constructor(x,y){
		super(x,y)
		this.color = COLORS.orange;
		this.alpha = 0;
	}
	draw(){
		ctx.fillStyle = this.color
		ctx.fillRect(this.x,this.y,this.w,this.h)
		if (this.alpha){
			this.drawAlpha()
			this.alpha = Math.max(this.alpha-.05,0)
		} 
	}
	drawShadow(){
		const offset = 4;
		ctx.fillStyle = COLORS.shadow
		ctx.fillRect(this.x-offset*2,this.y+offset,this.w+offset*2,this.h)
	}
}

class LandMine extends Block{
	constructor(x,y){
		super(x,y,GRID_THIRD,GRID_THIRD);
		this.sprite = new Sprite(SPRITE_DATA.mine_dat,30);
		this.color = [COLORS.red,COLORS.red2]
		this.bombSize = 12;
		this.alpha = 1;
		this.sign = -1;
	}
	draw(){
		const SQUARE = [this.x+this.offsetX,this.y+this.offsetY,this.bombSize,this.bombSize]
		ctx.fillStyle = this.color[0]
		this.sprite.draw(this.x,this.y);
		
		ctx.fillStyle = this.color[1]
		ctx.save();
		ctx.globalAlpha = this.alpha;
		ctx.fillRect(...SQUARE);
		ctx.restore();
		this.alpha += this.sign * .02
		if (this.alpha < 0){
			this.alpha = 0;
			this.sign = 1;
		}else if (this.alpha > 1){
			this.alpha = 1;
			this.sign = -1;
		}
	}
}

class PlayerCrab extends Block{
	constructor(x,y){
		super(x,y,GRID_THIRD,GRID_THIRD)
		this.xSpeed = this.speedMax = 4;
		this.ySpeed = 0;
		this.color = COLORS.red;
		this.state = 'walking' //walking,falling,dead
		this.alignX = 0;
	}
	
	update(){
		const walls = GAME.getOBJ('walls');
		const water = GAME.getOBJ('water');
		const enemies = GAME.getOBJ('enemies');
		var OBJ;
		switch(this.state){
			case 'walking':
				this.screenCheck()
				this.inputCheckY()
				
				if (OBJ = collideCheck(this,walls,0,0)){
					OBJ.alpha = 1;
					this.xSpeed *= -1;
					}
				this.x += this.xSpeed;
		
				if (OBJ = collideCheck(this,walls,0,this.ySpeed)){
					OBJ.alpha = 1;
					this.ySpeed = 0;
					}
				this.y += this.ySpeed	
				this.y = Math.min(this.y,C_HEIGHT-this.offsetY)
		
				if (OBJ = collideCheck(this,water)){
					this.alignX = OBJ.x;
					this.state = 'falling'
				}
			break;
			case 'falling':
				const speed = 2;
				this.y += this.speedMax;
				if (this.x >this.alignX)this.x = Math.max(this.x-speed,this.alignX)
				else if (this.x < this.alignX) this.x = Math.min(this.x+speed,this.alignX)
				if (!collideCheck(this,water,0,0)) this.state = 'walking';
		}
		if (OBJ = collideCheck(this,enemies)){
			this.dead = 1;
		}
	}
	
	draw(){
		ctx.fillStyle = this.color;
		SPRITES.crab.draw(this.x,this.y);
	}
	
	screenCheck(){
		const leftSide = 0 - this.w
		if (this.x > C_WIDTH) this.x = leftSide;
		else if(this.x < leftSide) this.x = C_WIDTH;
	}
	
	inputCheckY(){
		const verticalMove = controller.down-controller.up
		this.ySpeed = verticalMove * this.speedMax
		if (this.x < 0 || this.x+this.offsetX > C_WIDTH-this.offsetX) this.ySpeed = 0
	}
	
}

var levels = {
	1:BuildLevel(
	[
	'...11.......11...',
	'...11.......11...',
	'1..11.......11...',
	'1..11......111...',
	'...11......w11...',
	'...11......w11...',
	'...111.....w11...',
	'...111.....w11...',
	'...11w.....w11...',
	'...11w.....m11...',
	'...11w.....111...',
	'...11w.....111...',
	'...11w.....w11...',
	'...11m.....w11...',
	'...111.....m11...',
	'1..111......11..1',
	'1..11.......111.1',
	'...11.......11...',
	'...1111...1111...',
	'...1111...1111...'
	]),
	
	2:BuildLevel(
	[
	'.................',
	'.............1...',
	'1................',
	'1................',
	'.................',
	'....1............',
	'.................',
	'.................',
	'.................',
	'........1........',
	'.................',
	'.................',
	'....11111111.....',
	'.................',
	'.................',
	'1...............1',
	'1...............1',
	'.................',
	'.................',
	'.................'
	]),
	
	3:BuildLevel(
	[
	'.................',
	'...1.............',
	'..........1......',
	'.................',
	'.....111.....11..',
	'....11.1.........',
	'.................',
	'............www11',
	'1wwwwwww....www11',
	'1wwwwwww....www11',
	'1w.............11',
	'1w.............11',
	'1w.......1......1',
	'.w.........m....1',
	'.w...............',
	'1w.....1........1',
	'.w.....1........1',
	'1w...1111111....1',
	'1...............1',
	'111111.....111111',
	'.....1.....1.....'
	]),
	
	4:BuildLevel(
	[
	'1...............1',
	'1...............1',
	'1...............1',
	'1...............1',
	'1......111......1',
	'1.......1.......1',
	'1.......1.......1',
	'1....1111111....1',
	'1.1..m.....m..1.1',
	'1.1.....m.....1.1',
	'1.1111111111111.1',
	'1...............1',
	'11111111..1111111',
	'1w..............1',
	'1w..111111111...1',
	'1w..............1',
	'1............1..1',
	'1...............1',
	'1.....1.........1',
	'1...............1'
	])
}

function BuildLevel(map){
	var walls = [];
	var enemies = [];
	var water = [];
	for (let row = 0; row<map.length; row++){
		for (let col=0; col < map[row].length; col++){
			switch(map[row][col]){
				case '1':walls.push(new Wall(col,row))
				break;
				case'w':water.push(new Water(col,row))
				break;
				case'm':enemies.push(new LandMine(col,row))
				break;
			}
		}
	}
	return {enemies:enemies, walls:walls, water:water, allOBJs:[...walls,...water,...enemies]}
}
function drawLevel(level){
	
	level.walls.forEach(obj => {
		obj.drawShadow();
	})
	
	level.allOBJs.forEach(obj => {
		if (!obj.dead) obj.draw();
	})
}
class Wipe{
	constructor(){
		this.resetWipe();
		this.x = 0;
		this.y = C_HEIGHT;
		this.w = C_WIDTH;
		this.speed = 24;
	}
	update(){
			this.h = Math.min(this.h + this.speed, 0);
		}
	
	draw(){
		ctx.fillStyle = this.color;
		ctx.fillRect(this.x,this.y,this.w,this.h);
	}
	resetWipe(color=COLORS.blue){
		this.h = -C_HEIGHT;
		this.color = color;
	}
}
class GameController{
	constructor(){
		this.player = new PlayerCrab(8,8);
		this.screenWipe = new Wipe(COLORS.orange);
		this.currentLevel = 1;
		this.state = 'startScreen'
		this.resetScuttle();
		this.endScreen =	[	new Textbox('GAME OVER', Math.floor(C_WIDTH/5), Math.floor(C_HEIGHT/3),0,8),
								new Textbox('YOUR GOOSE IS COOKED!!',C_WIDTH/2, Math.floor(C_HEIGHT/3)+64,10)
							]
	}
	getOBJ(obj){
		return levels[this.currentLevel][obj];
	}
	checkNextLevel(){
		if (levels[this.currentLevel+1] == undefined )return
		if (this.player.y < 0 - GRID){
			this.currentLevel++
			this.player.y = C_HEIGHT
		}
	}
	setPlayerPos(x,y){
		this.player.x = x * GRID;
		this.player.y = y * GRID;
	}
	scuttleCheck(){
		if (controller.up){
				controller.up = 0;
				this.scuttleStart = 1;
			}
		if (this.scuttleStart){
			this.player.x += this.scuttleSpeed
			this.scuttleSpeed=Math.min(this.scuttleSpeed + .5, 12)
		}
	}
	resetScuttle(){
		this.scuttleStart = 0;
		this.scuttleSpeed = -5;
	}
}
var GAME = new GameController

function loop(){
	requestAnimationFrame(loop)
	ctx.clearRect(0,0,C_WIDTH,C_HEIGHT)
	switch (GAME.state){
		case 'startScreen':
			GAME.screenWipe.draw();
			GAME.player.draw();
			GAME.scuttleCheck();
			
			if(GAME.player.x > C_WIDTH+GRID*4){
				GAME.setPlayerPos(9,19);
				GAME.state = 'gameplay';
				GAME.resetScuttle();
			}
		
		break;
		case 'gameplay':
			drawLevel(levels[GAME.currentLevel])
			if (GAME.screenWipe.h !=0) GAME.screenWipe.update()
			else{
				GAME.player.draw()
				GAME.player.update()
				GAME.checkNextLevel()
				if (GAME.player.dead){
					GAME.state = 'gameOver';
					GAME.screenWipe.resetWipe(COLORS.red)
				}
			}
			GAME.screenWipe.draw();
		break;
		case 'gameOver':
			GAME.screenWipe.draw();
			ctx.fillStyle = 'white'
			GAME.endScreen[1].update();
			GAME.endScreen.forEach(message =>{
				message.draw();
			})
			ctx.fillRect(C_WIDTH/6,C_HEIGHT/3+50,360,4)
			if(controller.up){
				controller.up=0
				GAME.setPlayerPos(9,19);
				GAME.player.dead=0;
				GAME.state = 'gameplay';
				GAME.endScreen[1].resetText()
				GAME.currentLevel = 1;
			}
		break;
	}
}

loop()

document.addEventListener('keydown',(e)=>{
	if(e.keyCode == 38){
		controller.up = 1
	}
	else if(e.keyCode == 40){
		controller.down = 1
	}
})

document.addEventListener('keyup',(e)=>{
	controller.pressed = 0;
	controller.down = 0;
	controller.up = 0;
})


</SCRIPT>
</HTML>